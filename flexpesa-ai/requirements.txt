
fastapi==0.104.1
uvicorn==0.24.0
pydantic==2.5.0
sqlalchemy==2.0.23
pandas==2.1.4
yfinance==0.2.28

# app/core/config.py (SIMPLIFIED)
from pydantic import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    PROJECT_NAME: str = "Investment Portfolio MVP"
    API_V1_STR: str = "/api/v1"
    
    # Single Database (SQLite for MVP)
    DATABASE_URL: str = "sqlite:///./data/portfolio.db"
    
    # Optional API keys (not required for basic functionality)
    NEWS_API_KEY: Optional[str] = None
    
    class Config:
        env_file = ".env"

settings = Settings()

# app/core/database.py (SINGLE DATABASE)
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from .config import settings

# Single SQLite database for MVP
engine = create_engine(settings.DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# app/models/portfolio.py (SIMPLIFIED MODELS)
from sqlalchemy import Column, Integer, String, Float, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from app.core.database import Base
from datetime import datetime

class Account(Base):
    __tablename__ = "accounts"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, index=True)  # "Wells Fargo", "Stack Well", etc.
    account_type = Column(String)      # "brokerage", "retirement", etc.
    balance = Column(Float, default=0.0)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    assets = relationship("Asset", back_populates="account")

class Asset(Base):
    __tablename__ = "assets"
    
    id = Column(Integer, primary_key=True, index=True)
    account_id = Column(Integer, ForeignKey("accounts.id"))
    symbol = Column(String, index=True)     # "AAPL", "BTC-USD", etc.
    shares = Column(Float)
    avg_cost = Column(Float)
    current_price = Column(Float, default=0.0)
    last_updated = Column(DateTime, default=datetime.utcnow)
    
    account = relationship("Account", back_populates="assets")

# app/schemas/portfolio.py (SIMPLIFIED SCHEMAS)
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime

class AssetBase(BaseModel):
    symbol: str
    shares: float
    avg_cost: float

class AssetCreate(AssetBase):
    account_id: int

class Asset(AssetBase):
    id: int
    account_id: int
    current_price: float
    last_updated: datetime
    
    class Config:
        from_attributes = True

class AccountBase(BaseModel):
    name: str
    account_type: str

class AccountCreate(AccountBase):
    pass

class Account(AccountBase):
    id: int
    balance: float
    created_at: datetime
    assets: List[Asset] = []
    
    class Config:
        from_attributes = True

class PortfolioAnalysis(BaseModel):
    total_value: float
    day_change: float
    day_change_percent: float
    recommendation: str
    confidence: float
    risk_score: float

# app/services/market_data.py (SIMPLIFIED - Just yfinance)
import yfinance as yf
import pandas as pd
from typing import List, Dict
import logging

class MarketDataService:
    """Simple market data service using only yfinance"""
    
    @staticmethod
    def get_current_prices(symbols: List[str]) -> Dict[str, float]:
        """Get current prices for symbols"""
        try:
            if not symbols:
                return {}
                
            tickers = yf.Tickers(' '.join(symbols))
            prices = {}
            
            for symbol in symbols:
                try:
                    ticker = tickers.tickers[symbol]
                    hist = ticker.history(period="1d")
                    if not hist.empty:
                        prices[symbol] = float(hist['Close'].iloc[-1])
                except Exception as e:
                    logging.warning(f"Could not get price for {symbol}: {e}")
                    prices[symbol] = 0.0
            
            return prices
        except Exception as e:
            logging.error(f"Error fetching prices: {e}")
            return {symbol: 0.0 for symbol in symbols}
    
    @staticmethod
    def get_performance_data(symbols: List[str], period: str = "6mo") -> pd.DataFrame:
        """Get historical performance data"""
        try:
            data = yf.download(symbols, period=period, auto_adjust=True)
            if 'Close' in data.columns:
                return data['Close']
            return pd.DataFrame()
        except Exception as e:
            logging.error(f"Error fetching performance data: {e}")
            return pd.DataFrame()

# app/services/simple_ai.py (BASIC AI - No complex ML pipeline)
import pandas as pd
import numpy as np
from typing import Dict, List
import requests
from datetime import datetime, timedelta

class SimpleAIService:
    """Basic AI analysis without complex ML infrastructure"""
    
    def __init__(self, news_api_key: str = None):
        self.news_api_key = news_api_key
    
    def analyze_portfolio(self, accounts_data: List[Dict]) -> Dict:
        """Simple portfolio analysis"""
        total_value = sum(account['balance'] for account in accounts_data)
        
        # Simple risk calculation based on portfolio diversity
        num_assets = sum(len(account.get('assets', [])) for account in accounts_data)
        diversity_score = min(num_assets / 10, 1.0)  # More assets = less risk
        
        # Basic recommendation logic
        if diversity_score < 0.3:
            recommendation = "DIVERSIFY"
            confidence = 0.8
        elif total_value < 50000:
            recommendation = "ACCUMULATE"
            confidence = 0.7
        else:
            recommendation = "HOLD"
            confidence = 0.6
        
        return {
            "total_value": total_value,
            "diversity_score": diversity_score,
            "risk_score": (1 - diversity_score) * 10,
            "recommendation": recommendation,
            "confidence": confidence,
            "insights": [
                f"Portfolio spans {len(accounts_data)} accounts",
                f"Total of {num_assets} different assets",
                f"Diversity score: {diversity_score:.1%}"
            ]
        }
    
    def get_basic_sentiment(self, symbol: str) -> Dict:
        """Basic sentiment analysis using news (if API key available)"""
        if not self.news_api_key:
            # Return mock sentiment for MVP
            return {
                "sentiment": "neutral",
                "confidence": 0.5,
                "sources": ["Mock data - Add NEWS_API_KEY for real sentiment"]
            }
        
        try:
            # Simple news sentiment
            url = "https://newsapi.org/v2/everything"
            params = {
                "q": symbol,
                "sortBy": "relevancy",
                "pageSize": 10,
                "apiKey": self.news_api_key,
                "from": (datetime.now() - timedelta(days=7)).isoformat()
            }
            
            response = requests.get(url, params=params, timeout=10)
            if response.status_code == 200:
                articles = response.json().get("articles", [])
                
                # Simple sentiment scoring
                positive_words = ["buy", "bull", "up", "gain", "profit", "growth", "strong"]
                negative_words = ["sell", "bear", "down", "loss", "decline", "weak", "fall"]
                
                sentiment_score = 0
                for article in articles:
                    text = (article.get("title", "") + " " + article.get("description", "")).lower()
                    sentiment_score += sum(1 for word in positive_words if word in text)
                    sentiment_score -= sum(1 for word in negative_words if word in text)
                
                if sentiment_score > 0:
                    sentiment = "bullish"
                elif sentiment_score < 0:
                    sentiment = "bearish"
                else:
                    sentiment = "neutral"
                
                return {
                    "sentiment": sentiment,
                    "confidence": min(abs(sentiment_score) / 10, 1.0),
                    "sources": [f"{len(articles)} recent news articles"]
                }
        except Exception as e:
            logging.error(f"Sentiment analysis error: {e}")
        
        return {"sentiment": "neutral", "confidence": 0.5, "sources": ["Error fetching news"]}

# app/services/portfolio_service.py (CORE BUSINESS LOGIC)
from sqlalchemy.orm import Session
from app.models.portfolio import Account, Asset
from app.schemas.portfolio import AccountCreate, AssetCreate
from .market_data import MarketDataService
from .simple_ai import SimpleAIService
from typing import List, Dict
import logging

class PortfolioService:
    """Core portfolio management service"""
    
    def __init__(self, db: Session):
        self.db = db
        self.market_data = MarketDataService()
        self.ai_service = SimpleAIService()
    
    def create_account(self, account: AccountCreate) -> Account:
        """Create new investment account"""
        db_account = Account(**account.dict())
        self.db.add(db_account)
        self.db.commit()
        self.db.refresh(db_account)
        return db_account
    
    def add_asset(self, asset: AssetCreate) -> Asset:
        """Add asset to account"""
        db_asset = Asset(**asset.dict())
        self.db.add(db_asset)
        self.db.commit()
        self.db.refresh(db_asset)
        return db_asset
    
    def update_prices(self) -> Dict:
        """Update current prices for all assets"""
        assets = self.db.query(Asset).all()
        symbols = list(set(asset.symbol for asset in assets))
        
        current_prices = self.market_data.get_current_prices(symbols)
        
        updated_count = 0
        for asset in assets:
            if asset.symbol in current_prices:
                asset.current_price = current_prices[asset.symbol]
                updated_count += 1
        
        self.db.commit()
        return {"updated_assets": updated_count, "total_assets": len(assets)}
    
    def get_portfolio_summary(self) -> Dict:
        """Get complete portfolio summary"""
        accounts = self.db.query(Account).all()
        
        portfolio_data = []
        total_value = 0
        
        for account in accounts:
            account_value = sum(asset.shares * asset.current_price for asset in account.assets)
            account.balance = account_value  # Update balance
            
            portfolio_data.append({
                "id": account.id,
                "name": account.name,
                "balance": account_value,
                "assets": [
                    {
                        "symbol": asset.symbol,
                        "shares": asset.shares,
                        "current_price": asset.current_price,
                        "value": asset.shares * asset.current_price
                    }
                    for asset in account.assets
                ]
            })
            total_value += account_value
        
        # Get AI analysis
        ai_analysis = self.ai_service.analyze_portfolio(portfolio_data)
        
        return {
            "accounts": portfolio_data,
            "total_value": total_value,
            "analysis": ai_analysis
        }

# app/api/routes.py (SINGLE FILE FOR ALL ROUTES)
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.core.database import get_db
from app.schemas.portfolio import Account, AccountCreate, Asset, AssetCreate, PortfolioAnalysis
from app.services.portfolio_service import PortfolioService
from typing import List

router = APIRouter()

@router.get("/portfolio/summary")
def get_portfolio_summary(db: Session = Depends(get_db)):
    """Get complete portfolio summary - MAIN ENDPOINT for dashboard"""
    service = PortfolioService(db)
    return service.get_portfolio_summary()

@router.post("/portfolio/update-prices")
def update_prices(db: Session = Depends(get_db)):
    """Update current prices for all assets"""
    service = PortfolioService(db)
    return service.update_prices()

@router.post("/accounts/", response_model=Account)
def create_account(account: AccountCreate, db: Session = Depends(get_db)):
    """Create new investment account"""
    service = PortfolioService(db)
    return service.create_account(account)

@router.get("/accounts/", response_model=List[Account])
def get_accounts(db: Session = Depends(get_db)):
    """Get all accounts"""
    return db.query(Account).all()

@router.post("/assets/", response_model=Asset)
def add_asset(asset: AssetCreate, db: Session = Depends(get_db)):
    """Add asset to account"""
    service = PortfolioService(db)
    return service.add_asset(asset)

@router.post("/analysis/quick")
def quick_analysis(symbols: List[str], db: Session = Depends(get_db)):
    """Quick AI analysis for specific symbols"""
    service = PortfolioService(db)
    
    results = {}
    for symbol in symbols:
        sentiment = service.ai_service.get_basic_sentiment(symbol)
        results[symbol] = sentiment
    
    return {"analysis": results}

# app/main.py (SIMPLIFIED)
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.core.config import settings
from app.core.database import engine, Base
from app.api.routes import router

# Create database tables
Base.metadata.create_all(bind=engine)

app = FastAPI(
    title=settings.PROJECT_NAME,
    description="Simple Investment Portfolio Management",
    version="1.0.0"
)

# Enable CORS for frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routes
app.include_router(router, prefix=settings.API_V1_STR)

@app.get("/")
def root():
    return {
        "message": "Investment Portfolio MVP API",
        "endpoints": {
            "portfolio_summary": "/api/v1/portfolio/summary",
            "update_prices": "/api/v1/portfolio/update-prices",
            "accounts": "/api/v1/accounts/",
            "assets": "/api/v1/assets/"
        }
    }

# run.py (SIMPLE STARTUP)
import uvicorn
from app.main import app

if __name__ == "__main__":
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        reload=True
    )

